# 배열

그동안 우리는 많은 데이터를 저장하기 위해 주로 배열을 사용했습니다. 이후에는 배열이 아닌 수많은 자료구조에 대해 학습하겠지만, 일단 배열의 특성을 이해하고 어떤 장점과 단점이 있는지 알아봅시다.

우리는 배열로 무엇을 하나요? 주로 값을 담고, 값을 배열에서 삭제하고, 원하는 값을 배열에서 찾습니다. 이런 삽입, 삭제, 탐색 연산을 일반적으로 기본 연산이라고 부릅니다.

각각의 시간복잡도를 생각해봅시다.

## 삽입

실제로는 값을 어디에 삽입하냐에 따라 시간복잡도는 달라집니다. 다만, 보통 시간복잡도라 부를 때에는 **최악의 상황에서의 시간복잡도를** 얘기합니다.

배열이 주어졌을 때, 앞이나 가운데에 값을 넣는다고 가정합시다. 이렇게 되면 다음과 같이 새로운 값이 들어갈 자리를 확보하기 위해 다른 값들이 한칸씩 이동해야 합니다. 따라서 일반적으로 삽입의 시간복잡도는 O(N)이 됩니다.

다만, 항상 배열의 맨 뒤에 새로운 값을 삽입하는 경우만 발생한다면, 이런 경우엔 다른 값들의 이동이 전혀 존재하지 않기 때문에 O(1) 의 시간복잡도를 보일 것입니다.

![](https://contents.codetree.ai/problems/444/images/introductions-c4d0fbb2-e2c4-4d9f-8b08-41852eea24ff.svg)

## 삭제

삽입과 마찬가지로, 맨 뒤의 값을 제거하게 된다면 O(1)이 걸릴 것입니다. 그러나 삭제의 주 목적은 우리가 원하는 값을 지우는 것이기 때문에, 맨 뒤의 값이 아닌 다른 값을 제거하는 경우도 살펴봐야 할 것입니다.

이런 경우엔, 삽입 과정에서 설명했던 것과 유사하게 다른 값들의 이동이 따라옵니다.

최악의 경우, 맨 앞의 값을 삭제하게 된다면 나머지 N-1개의 값들이 모두 이동해야 하기 때문에 O(N)의 시간복잡도를 보일 것입니다.

## 탐색

원하는 값을 찾으려면 어떤 방법이 있을까요?

가장 간단한 방법은 바로 처음부터 모든 값을 훑는 것입니다.

당연히 맨 끝에 값이 존재한다면 모든 값을 탐색해야 할 겁니다. 그렇게 된다면 자연스럽게 탐색의 시간복잡도도 마찬가지로 O(N)이라고 볼 수 있을 겁니다.

## k번째 원소 값 구하기

배열이 주어졌을 때, k번째 원소를 찾는 데 걸리는 시간은 어떻게 될까요?  
배열은 index 기반으로 이루어져 있기 때문에 k - 1번째 index를 참조하면 바로 k번째 원소를 구할 수 있습니다. 따라서 이 경우의 시간복잡도는 O(1)이 됩니다.