
# 대입과 조건문의 시간복잡도

자. 드디어 프로그램의 성능을 평가할 때가 왔습니다!

내가 프로그램을 잘 짰는지, 아니면 비효율적으로 짰는지 확인하는 방법은 여러 가지가 있겠지만, 저희는 앞으로 코드를 분석해 코드의 효율성을 확인하려고 합니다. 그러기 위해선 어떤 식으로 코드를 분석해야 할지 알아야 합니다.

우선 가장 단순하지만, 가장 확실한 방법을 사용해봅시다. 바로, 연산이 몇 번 진행되었는지 계산하는 것입니다. 단순하게 생각해보면, 똑같은 일을 하는 두 코드가 있다면, 당연히 더 많은 연산을 필요로 하는 코드가 더 비효율적일 겁니다.

그러나 문제라면, 연산 횟수를 세는 것은 코드가 길어지면 많은 시간이 걸린다는 점, 그리고 반복문이나 재귀함수 같은 것들이 등장하게 된다면 횟수를 세는 것이 매우 깐깐해진다는 것입니다. 그러므로 우리는 코드의 실행 횟수를 일일이 세지 않고, 점근적 표기법을 사용할 것입니다.

우리는 연산의 횟수를 점근적 표기법을 통해 추상적으로 표현하게 된다면, 그것을 **시간복잡도** 라고 부를 것입니다!

## 기본 연산

강제로 여러 줄의 코드를 한 줄로 몰지 않는 이상, 한 줄에는 하나의 명령이 올 것 입니다.

가장 간단한 연산은 역시 대입일 것입니다.

```js
set a = 10
```

실제로 a라는 변수를 만들고, 10이라는 값을 할당하는 과정에서 컴퓨터는 많은 연산을 하지만, 우리는 단순하게 O(1)의 연산을 수행했다고 볼 것입니다.

조건문도 비슷합니다.

```js
set a = 5
if a != 10
  print('hello')
```

`print` 같은 메서드를 O(1)이라고 가정한다면, 대입도 O(1)이고 `print`도 O(1)이니 `if a != 10` 만 정확하게 알면 될 것 입니다.

그러나 결국 단순히 두 값을 비교하는 연산을 수행하기 때문에, 결과적으로 조건문도 O(1)의 시간복잡도를 보여주게 됩니다.

따라서 위 코드의 시간복잡도는 O(1)이라고 할 수 있을 것 입니다.

이처럼 우리는 앞으로 O 표기법을 이용해 시간복잡도를 표현하게 될 것입니다.  
그렇다면 시간복잡도는 어디에 쓰일 수 있을까요?

**보통 for loop을 1억번 도는 데 걸리는 시간이 1초 정도 됩니다.** 이를 이용하면 다음과 같은 사실을 알 수 있습니다.

제한시간이 1초인 경우에 대해 떠올린 솔루션의 시간복잡도를 O로 계산했다고 생각해봅시다. **그러면 N의 범위에 따라 제한 시간 안에 올바른 답이 나오는 솔루션인지를 빠르게 파악할 수 있습니다.**

- N≤10
    O(N!), O(2N), O(3N)
    
- N≤20
    O(2N)
    
- N≤100
    O(N4)
    
- N≤500
    O(N3)
    
- N≤1,000
    O(N2), O(N2logN)
    
- N≤100,000
    O(N), O(NlogN), O(logN), O(1)
    

따라서 제한시간과 솔루션의 시간복잡도를 비교해보고, 만약 시간안에 나오지 않는다면 다른 솔루션을 떠올려봐야만 합니다.