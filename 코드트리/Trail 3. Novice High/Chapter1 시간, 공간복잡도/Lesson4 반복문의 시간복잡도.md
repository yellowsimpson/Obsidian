# 반복문에서의 시간복잡도

앞에서 여러 번 언급했지만, 반복문에서의 시간복잡도는 조금 복잡해집니다. 그러나 원리를 잘 이해하시고 차근차근 문제를 풀어보시면 비교적 쉽게 이해하실 수 있을 겁니다!!

## 시간복잡도의 기준

앞에서 기본 연산들을 기반으로 시간복잡도를 계산할 땐 상관 없겠지만, while 문이 코드에 들어온다면 시간복잡도는 조금 복잡해 질 것 입니다. 반복문을 언제 빠져나올 지 확실하지 않기 때문입니다!

다음과 같은 코드를 봅시다.

```jsx
function example(n)
  while 0 > n or n > 100
    if n < 0
      n++
    else
      n--
  return n
```

이런 코드의 경우 n에 값에 따라 연산의 횟수가 달라질 수 밖에 없으므로, 생각하기 어려울 것 입니다.

사실, 시간복잡도는 일반적으로 최악을 기준으로 계산합니다. 우리가 시간복잡도를 계산하는 이유가 프로그램의 성능을 체크하기 위함이었죠? 당연히 입력값이 아주 크거나 시간이 오래 걸리는 데이터도 들어올 가능성이 존재하므로 최악의 경우를 고려하면 어떠한 상황에서도 프로그램의 성능이 뛰어난지 확인할 수 있을 것입니다.

이 점을 상기한 채로, 반복문의 시간복잡도에 대해 알아봅시다.

## for

다음과 같은 코드가 있다고 해 봅시다.

```jsx
set x = 0
for i = 0 ... i < 10
  x += 1
  print(x)
```

for문에 의하여 반복문 내부는 10번 반복됩니다. 여러분들은 이미 내부의 코드의 시간복잡도가 O(1) 이라는 것을 알기 때문에, 10번 반복을 해도 결국 시간복잡도는 O(1∗10)=O(1)이 될 것 입니다.

그러나 위에서 소개한 코드 처럼 불분명한 값이 들어오게 되면 상황은 달라집니다.

```jsx
function example(n)
  set x = 0
  for i  = 0 ... i < n
    x += 1
    print(x) 
```

조금 당황스러울 수도 있지만, 하던 대로 해봅시다. 당연히 for문 내부의 코드의 시간복잡도는 O(1)이니, N번 반복을 수행하게 된다면 O(N)이 될 것입니다.

N의 값을 판단할 수 없기 때문에, 일반적으로는 N을 그냥 둡니다.

그렇다면 다음 코드는 어떨까요?

```jsx
set x = 0
for i = 0 ... i < n / 2
  x += 1
  print(x)
```

이 코드는 n / 2​번 수행이 되겠지만, O 표기법은 **상수를 무시** 하기 때문에 마찬가지로 O(N)임에 유의합니다.

## while

while 문의 경우, 반복문을 탈출할 수 있는 조건이 불분명 하므로 for에 비해 생각해야 할 것이 많습니다.

앞에서 다룬 예제를 다시 가져와보겠습니다.

```jsx
function example(n)
  while 0 > n or n > 100
    if n < 0
      n++
    else
      n--
  return n
```

n이 0과 100 사이에 있다면 반복문에 진입 자체를 안 하기 때문에 O(1)의 시간이 소요됩니다. 그렇지만 이걸 시간복잡도라고 할 수 있을까요?

n이 만약에 엄청나게 큰 값이라고 합시다. 그렇다면 100 이하가 될 때 까지 계속 내부를 순회해야 하기 때문에, 이론적으로 N - 100회의 순회가 필요할 것 입니다. 따라서 시간복잡도는 자연스럽게 O(1∗(N−100))=O(N) 이 될 것 입니다.

이런 부분을 잘 판단하시고 시간복잡도를 하나씩 구해 봅시다.

## Side Note

다음 코드의 시간복잡도는 어떻게 될까요?

```jsx
set x = 0
for i = 0 ... i < n
  for j = 5 ... j < n
      x += 1
      print(x)

for i = 0 ... i < n
    x += 1

print(x)
```

위의 포문은 O(N^2), 아래 포문은 O(N) 이지만 N^2이 항상 N보다 크다고 할 수 있기 때문에 해당 코드의 시간복잡도는 O(N^2)이 됩니다.