상위 수준 언어 프로그램과 달리 산술 명령어의 피연산자에는 __'레지스터(register)'__ 라는 제약이 있다.

LEGv8 어셈블리어 에서 레지스터의 크기는 __64비트__ 이다.
	-> 32비트: 워드(word)
	-> 64비트: 더블 워드(doubleword)


<하드웨어설계 원칙>
1.  간단하기 위해서는 규칙적인 것이 좋다.
2. 작은 것이 더 빠르다.

예제
다음을 어셈블리어로 바꾸시오
```c
f = (g + h) - (i + j);
```

정답
```asm
ADD X9, X20, X21 
ADD X10, X22, X23
SUB X19, X9, X10
```

- 프로세스는 소량의 데이터 저장
- 메모리는 수십억개의 데이터 저장

메모리와 레지스터 간에 데이터를 주고받는 명령어: 데이터 전송 명령어
메모리 주소는 인덱스 역할을 하는 큰 일차원 배열이다.
	-> 주소는 0부터 시작
메모리 주소는 명령어의 상수 부분과 두 번째 레지스터값의 합으로 구해진다.

![[스크린샷 2025-09-22 오후 5.29.30.png]]


예제 
A는 더블워드 배열이고, 변수 g, h는 레지스터 X20, X21에 할당되어 있다. 배열 A의 시작 주소는 X22에 기억되어 있다. 다음 C언어를 컴파일하라
```c
g = h + A[8];
```
정답
```c
LDUR X9, [X22, #8] //A[8]을 레지스터로 옮긴 후 연산을 시작
				   //X22(배열 시작 주소) + 8
				   //X9는 X22의 주소를 넣기 위함 임시 레지스터
ADD X20, X21, X9 //g = h + A[8]
```
- 데이터 전송 명령어의 상수 부분(8): 변위
- 레지스터(X22): 베이스 레지스터(base register)

![[스크린샷 2025-09-22 오후 5.44.16.png]]

컴파일러의 임무
- 변수와 레지스터를 연관 짓는다
- 배열이나 구조체 같은 자료구조를 메모리에 할당함

최상위(big end)(제일 왼쪽) 바이트 주소를 더블워드 주소로 사용하는 컴퓨터
최하위(little end)(제일 오른쪽) 바이트 주소를 더블워드 주소로 사용하는 컴퓨터


STUR(store register): 메모리 저장 명령어

STUR 사용 예시

값 저장
```asm
MOV X0, #10        // X0 ← 10
MOV X1, #1000      // X1 ← 1000 (메모리 주소 기준)
STUR X0, [X1, #0]  // X0 값을 X1이 가리키는 메모리 주소(1000)에 저장
```

